// global vars
global hits, misses, io, vfs

function show_time_(event: string) {
  t = gettimeofday_ns()
  secs = t / 1000000000
  micros = t % 1000000000
  printf("t=%d.%09d event=%s", secs, micros, event)
}

function show_time(event: string) {
  show_time_(event)
  print(" ")
}

function rwhelper(name: string, devname: string, nbytes: long) {
  if (nbytes > 0 && pid() == target()) {
    if (devname == "N/A")
      tag = sprintf("%s.cached", name)
    else
      tag = sprintf("%s.uncached", name)
    io[tag] += nbytes
  }
}

global rlat, wlat
global rtim, wtim

probe vfs.read {
  rlat[tid()] = gettimeofday_ns()
}

probe vfs.write {
  wlat[tid()] = gettimeofday_ns()
}

// bitcoin does not use readv
probe vfs.read.return {
  rwhelper("read", devname, $return)
  rtim <<< gettimeofday_ns() - rlat[tid()]
}

// bitcoin does not use writev
probe vfs.write.return {
  rwhelper("write", devname, $return)
  wtim <<< gettimeofday_ns() - wlat[tid()]
}

global fop
probe generic.fop.* {
  if (pid() == target()) {
    fop[name]++
  }
}

function show_fop() {
  show_time_("fop")
  foreach([name] in fop) {
    count = fop[name]
    printf(" %s=%d", name, count)
  }
  println()
  delete fop
}

probe vfs.* {
  if (pid() == target()) {
    vfs[name]++
  }
}

probe bitcoind = process("/home/evan/code/bitcoin/src/bitcoind") {
}

// record when cache flushes start
probe bitcoind.mark("cache__flush") {
  show_time("flush")
  printf("num_coins=%lu num_bytes=%lu\n", $arg1, $arg2)
}

// record cache hits
probe bitcoind.mark("cache__hit") {
  hits++
}

// record cache misses
probe bitcoind.mark("cache__miss") {
  misses++
}

function show_cache() {
  show_time("cache")
  printf("hits=%d misses=%d\n", hits, misses)
  hits=0
  misses=0
}

probe bitcoind.mark("finish__ibd") {
  show_time("finish_ibd")
  println()
  exit()
}

/*
global dbgets
probe bitcoind.function("CCoinsViewDB::GetCoin") {
  dbgets++
}
*/

probe bitcoind.mark("update__tip") {
  show_time("update_tip")
  printf("height=%lu utxo_count=%lu utxo_memory=%lu ldb_count=%lu progress=0.%06d\n", $arg1, $arg2, $arg3, $arg4, $arg5)
}

global ioreqs
probe ioblock_trace.request {
  ioreqs++
}

function show_blockio() {
  show_time("blockio")
  printf("reqs=%lu\n", ioreqs)
  ioreqs = 0
}


  /*
   global oldsec, blockio
  global bios, biotime

probe kernel.function("generic_make_request") {
  if (pid() == target()) {
    bios[$bio] = gettimeofday_ns()
  }
}

probe kernel.function("bio_endio") {
  if (pid() == target()) {
    t = gettimeofday_ns() - bios[$bio]
    delete bios[$bio]
    biotime <<< t
  }
}

probe ioblock_trace.request {
  if (size != 0 && pid() == target()) {
    if (sector != oldsec) {
      blockio["seeks"]++
    }
    blockio["requests"]++
    blockio["bytes"] += size
  }

  //blockreqs[bdev, sector, size] = gettimeofday_ns()
}

// N.B. This is not called reliably, because the kernel can merge block io
// requests.
probe ioblock_trace.end {
  if (size != 0 && pid() == target()) {
    sectorsize = (@defined($q->limits->logical_block_size)
                  ? $q->limits->logical_block_size
                  : (@defined($q->logical_block_size) ? $q->logical_block_size
                     : $q->hardsect_size))
    oldsec = sector + (size/sectorsize)
    blockio["completed"]++
  }
}

global blocktiming, blockreqs

probe ioblock_trace.end {
  if (size == 0) next
  if (pid() != target()) next
  prevtime = blockreqs[bdev, sector, size]
  if (prevtime) {
    elapsed = gettimeofday_ns() - blockreqs[bdev, sector, size]
    blocktiming <<< elapsed
    delete blockreqs[bdev, sector, size]
  }
}

function show_blockio() {
  show_time_("blockio")
  foreach([name] in blockio) {
    count = blockio[name]
    printf(" %s=%d", name, count)
  }
  if (@sum(biotime)) {
    printf(" avglatency=%lu", @avg(biotime))
    delete biotime
  }
  println()
  delete blockio
}
*/

function show_io() {
  show_time_("io")
  foreach([name] in io) {
    count = io[name]
    printf(" %s=%d", name, count)
  }
  println()
  delete io
}

function show_vfs() {
  show_time_("vfs")
  foreach([name] in vfs) {
    count = vfs[name]
    printf(" %s=%d", name, count)
  }
  println()
  delete vfs
}

function show_latency() {
  show_time_("latency")
  if (@sum(rtim)) {
    printf(" avgread=%lu", @avg(rtim))
    delete rtim
  }
  if (@sum(wtim)) {
    printf(" avgwrite=%lu", @avg(wtim))
    delete wtim
  }
  println()
}

probe timer.sec(1) {
  show_cache()
  show_io()
  show_vfs()
  show_fop()
  show_latency()
  show_blockio()
}
