// global vars
global hits, misses, io, vfs

function show_time_(event: string) {
  t = gettimeofday_ns()
  secs = t / 1000000000
  micros = t % 1000000000
  printf("t=%d.%09d event=%s", secs, micros, event)
}

function show_time(event: string) {
  show_time_(event)
  print(" ")
}

function rwhelper(name: string, devname: string, nbytes: long) {
  if (nbytes > 0 && pid() == target()) {
    if (devname == "N/A")
      tag = sprintf("%s.cached", name)
    else
      tag = sprintf("%s.uncached", name)
    io[tag] += nbytes
  }
}

// bitcoin does not use readv
probe vfs.read.return {
  rwhelper("read", devname, $return)
}

// bitcoin does not use writev
probe vfs.write.return {
  rwhelper("write", devname, $return)
}

/*
 global fop
probe generic.fop.* {
  if (pid() == target()) {
    fop[name]++
  }
}

function show_fop() {
show_time_("fop")
foreach([name] in fop) {
count = fop[name]
printf(" %s=%d", name, count)
}
println()
delete fop
}

*/

probe vfs.* {
  if (pid() == target()) {
    vfs[name]++
  }
}

probe bitcoind = process("/home/evan/code/bitcoin/src/bitcoind") {
}

// record when cache flushes start
probe bitcoind.mark("cache__flush") {
  show_time("flush")
  printf("num_coins=%lu num_bytes=%lu\n", $arg1, $arg2)
}

// record cache hits
probe bitcoind.mark("cache__hit") {
  hits++
}

// record cache misses
probe bitcoind.mark("cache__miss") {
  misses++
}

function show_cache() {
  show_time("cache")
  printf("hits=%d misses=%d\n", hits, misses)
  hits=0
  misses=0
}

probe bitcoind.mark("finish__ibd") {
  show_time("finish_ibd")
  println()
  exit()
}

/*
global dbgets
probe bitcoind.function("CCoinsViewDB::GetCoin") {
  dbgets++
}
*/

probe bitcoind.mark("update__tip") {
  show_time("update_tip")
  printf("height=%lu utxo_count=%lu utxo_memory=%lu ldb_count=%lu progress=0.%06d\n", $arg1, $arg2, $arg3, $arg4, $arg5)
}

global oldsec, blockio

probe ioblock_trace.request {
  if (size == 0) next
  if (pid() != target()) next
  sectorsize = (@defined($q->limits->logical_block_size)
		? $q->limits->logical_block_size
		: (@defined($q->logical_block_size) ? $q->logical_block_size
		   : $q->hardsect_size))
  if (sector != oldsec) {
    blockio["seeks"]++
  }
  oldsec = sector + (size/sectorsize)
  blockio["requests"]++
  blockio["bytes"] += size
  // TODO: use rw field
}

function show_blockio() {
  show_time_("blockio")
  foreach([name] in blockio) {
    count = io[name]
    printf(" %s=%d", name, count)
  }
  println()
  delete blockio
}

function show_io() {
  show_time_("io")
  foreach([name] in io) {
    count = io[name]
    printf(" %s=%d", name, count)
  }
  println()
  delete io
}

function show_vfs() {
  show_time_("vfs")
  foreach([name] in vfs) {
    count = vfs[name]
    printf(" %s=%d", name, count)
  }
  println()
  delete vfs
}

probe timer.sec(1) {
  show_cache()
  show_io()
  show_vfs()
  show_blockio()
}
